package app.server;

import java.io.*;
import java.net.*;

import app.GUI.Pages.MainPage;
import shared.UserIdentifier;
import shared.LocationUpdate;

import javafx.geometry.Point3D;
 
/**
 * This thread handles connection for each connected client, so the server
 * can handle multiple clients at the same time.
 * 
 * Note that each 'client' is a unique username+group combination.
 * Therefore, a user in 4 groupchats will have 4 client connections.
 *
 * @author www.codejava.net
 * @author Adapted by Sean McNamee
 */
public class UserThread extends Thread {
    private Socket socket;
    private UserIdentifier userInfo; //The unique identifier for a thread
    private ChatServer server; //Because it has to broadcast messages to everyone

    private final String SERVER_INFO = "SERVER";
    private final String USER_MESSAGE = "USER";

    private ObjectOutputStream writer;

    //TODO deal with securely closing sockets better?
    //This isn't even triggered. Should the client just send this when their application is closed?
    //Should this be generated by the client and sent here along with the username and group?
    private static String ENDING_STRING = "fjkdsafueiwfjdsafuernavahkfjdsa";
    private MainPage guiPage;
 
    public UserThread(MainPage guiPage, Socket socket, ChatServer server) {
        this.socket = socket;
        this.server = server;
        this.guiPage = guiPage;
    }
 
    /**
     * Initializes reader and writer. Recieves identifier information (username/group)
     * Waits for input from the socket so it can be broadcasted.
     */
    public void run() {
        try {
            OutputStream output = socket.getOutputStream();
            writer = new ObjectOutputStream(output);
            
            InputStream input = socket.getInputStream();
            ObjectInputStream reader = new ObjectInputStream(input);
 
            try {
                LocationUpdate startingLocation = (LocationUpdate) reader.readObject();
                this.userInfo = startingLocation.getUserInfo();
                server.broadcast(startingLocation, this); //Send over new user
            } catch (ClassNotFoundException e) {
                System.out.println("Handshake failed");
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
 
            String serverMessage = "New user connected to " + this.userInfo.getGroupName() + ": " + this.userInfo.getUserName();
            guiPage.addConnection(serverMessage);
 
            LocationUpdate locationUpdate = null;
            
            //Broadcast any recieved message. Note the variable names
            do {
                try {
                    locationUpdate = (LocationUpdate) reader.readObject();
                    
                    serverMessage = locationUpdate.getPosition().toString();
                    
                } catch (ClassNotFoundException e) {
                    serverMessage = "Failed to reader client message";
                    e.printStackTrace();
                } //In from the client
                
                guiPage.addBroadcast(serverMessage);
                server.broadcast(locationUpdate, this); //Send over updated location
 
            } while (locationUpdate != null);
 
            server.removeUser(this);
            socket.close();
 
            serverMessage = userInfo.getUserName() + " has quitted.";
            guiPage.addConnection(serverMessage);
            server.broadcast(new LocationUpdate(new Point3D(0, 0, 0), userInfo), this);
 
        } catch (IOException ex) {
            System.out.println("Error in UserThread: " + ex.getMessage());
            guiPage.addConnection("'Error' in UserThread (Disconnected/quit): " + ex.getMessage());
            ex.printStackTrace();
        }
    }
 

    /**
     * Sends a message to the client.
     */
    void sendMessage(LocationUpdate update) {
        try {
            writer.writeObject(update);
        } catch (IOException e) {
            guiPage.addConnection("Failed to send message: " + update);
            e.printStackTrace();
        }
    }

    public String getUserName() {
        return this.userInfo.getUserName();
    }

    public String getGroup() {
        return this.userInfo.getGroupName();
    }
    
}